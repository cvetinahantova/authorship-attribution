A recent visitor on the Ruby mailing list (who seems to me had a C/C++ background) asked why in Ruby zero was not false. This sparked some comments, but as of the time of me reading it no one had considered Ruby's ancestry. Ruby borrows many good concepts from languages all over the board. That was done on purpose, and done very well I would say. Two languages that heavily influenced Ruby were Smalltalk and Scheme. Now, one Scheme had the following idea: Everything is true except  false . More on this later, but first to C, where zero  is  true: I recall Dr. Michaud talking about why zero was a convenient  false  in C (well, he didn't say exactly that, but went on about a nice talk on why there is no "bit" type in C, and that can be applied here) - this is because zero is an integer, and integers can be nicely fit into a byte/word. Boolean true/false values on the other hand would need only a bit, but would need a byte/word to be allocated anyway. This is a huge waste of allocation space, which not so long ago was a quite precious resource. Plus, integers can do all these nifty things, like addition, substraction, factorial, and so on and so forth. Since zero is the nicest non-positive integer, it makes just sense to use it as false. It also takes the least effort to represent, so it's better at being false than a negative number, and doesn't encompass an entire range.  Now back to Ruby. In Ruby, integers are just another subtype of objects. And why should an object, something that has been given metadata, be considered false? It doesn't make sense. Effectively, this makes everything except  false  true. But there's more! In Ruby, as in Scheme,  nil  is also false. This follows directly from the previous definition of false, because  nil  is not something, and therefore does not belong to everything.  And that is the story on why only  false  and  nil  are false in Ruby.